#------------------------------------------------------------------------------
# written by: Lawrence McDaniel
#             https://lawrencemcdaniel.com/
#
# date: Mar-2022
#
# usage: use Helm to add a Kubernetes ingress ALB controller
#        using the AWS-sponsored helm chart
#
# see:
# - https://artifacthub.io/packages/helm/aws/aws-load-balancer-controller
# - https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/
# - https://github.com/aws/eks-charts/tree/master/stable/aws-load-balancer-controller
# - https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# written by: Benjamin P. Jung
#             headcr4sh@gmail.com
#
#             U.S. General Services Administration
#             https://open.gsa.gov
#             https://github.com/GSA/terraform-kubernetes-aws-load-balancer-controller
#             forked from : https://registry.terraform.io/modules/iplabs/alb-ingress-controller/kubernetes/latest
#
# mcdaniel mar-2022:
# i've seen this same code in many other places, but this is the only set that
# actually worked, and it looks like its being actively maintained by GSA.
# The latter half of this article, written by Harshet Jain, provides a
# good explanation of how this works:
# https://betterprogramming.pub/with-latest-updates-create-amazon-eks-fargate-cluster-and-managed-node-group-using-terraform-bc5cfefd5773
#
#     "external-dns.alpha.kubernetes.io/hostname" : "${var.environment_domain}"
#     "external-dns.alpha.kubernetes.io/hostname" : "*.${var.environment_domain}"
#
#
# https://github.com/kubernetes-sigs/aws-load-balancer-controller/issues/2039
#
# Setup instructions:
# -------------------
# https://aws.github.io/eks-charts/aws-load-balancer-controller
# https://github.com/aws/eks-charts/tree/v0.0.82/stable/aws-load-balancer-controller
# https://aws.amazon.com/premiumsupport/knowledge-center/eks-alb-ingress-controller-fargate/
#
#------------------------------------------------------------------------------


  # https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.4/guide/ingress/annotations/
  # https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/guide/ingress/cert_discovery/
  # https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/guide/integrations/external_dns/
  #
  # mcdaniel: automatic cert discovery is enabled by **NOT** including alb.ingress.kubernetes.io/certificate-arn

  enable_host_networking    = false
  k8s_pod_labels            = {}
  chart_env_overrides       = {}
  target_groups             = []
  k8s_replicas              = 2
  k8s_pod_annotations = {
    "alb.ingress.kubernetes.io/load-balancer-name" : "${var.environment_namespace}",
    "alb.ingress.kubernetes.io/ip-address-type" : "ipv4"
    "alb.ingress.kubernetes.io/scheme" : "internet-facing",
    "alb.ingress.kubernetes.io/security-groups" : aws_security_group.sg_alb.name,
    "alb.ingress.kubernetes.io/load-balancer-attributes" : "",
    "alb.ingress.kubernetes.io/listen-ports" : jsonencode([{ "HTTP" : 80 }, { "HTTPS" : 443 }, { "HTTP" : 8080 }, { "HTTPS" : 8443 }]),
    "alb.ingress.kubernetes.io/ssl-redirect" : "443",
    "alb.ingress.kubernetes.io/target-type" : "ip",
    "alb.ingress.kubernetes.io/backend-protocol" : "HTTP",
    "alb.ingress.kubernetes.io/target-group-attributes" : "",
    "alb.ingress.kubernetes.io/healthcheck-port" : "80",
    "alb.ingress.kubernetes.io/healthcheck-path" : "/",
    "alb.ingress.kubernetes.io/healthcheck-interval-seconds" : "15",
    "alb.ingress.kubernetes.io/healthcheck-timeout-seconds" : "5",
    "alb.ingress.kubernetes.io/healthy-threshold-count" : "2",
    "alb.ingress.kubernetes.io/unhealthy-threshold-count" : "2",
    "alb.ingress.kubernetes.io/success-codes" : "200",
    "alb.ingress.kubernetes.io/target-node-labels" : "label1=nginx"
  }




# Generate a kubeconfig file for the EKS cluster to use in provisioners
data "template_file" "kubeconfig" {
  template = <<-EOF
    apiVersion: v1
    kind: Config
    current-context: terraform
    clusters:
    - name: ${data.aws_eks_cluster.cluster.name}
      cluster:
        certificate-authority-data: ${data.aws_eks_cluster.cluster.certificate_authority.0.data}
        server: ${data.aws_eks_cluster.cluster.endpoint}
    contexts:
    - name: terraform
      context:
        cluster: ${data.aws_eks_cluster.cluster.name}
        user: terraform
    users:
    - name: terraform
      user:
        token: ${data.aws_eks_cluster_auth.cluster.token}
  EOF
}

# Since the kubernetes_provider cannot yet handle CRDs, we need to set any
# supplied TargetGroupBinding using a null_resource.
#
# The method used below for securely specifying the kubeconfig to provisioners
# without spilling secrets into the logs comes from:
# https://medium.com/citihub/a-more-secure-way-to-call-kubectl-from-terraform-1052adf37af8
#
# The method used below for referencing external resources in a destroy
# provisioner via triggers comes from
# https://github.com/hashicorp/terraform/issues/23679#issuecomment-886020367
resource "null_resource" "supply_target_group_arns" {
  count = (length(var.target_groups) > 0) ? length(var.target_groups) : 0

  triggers = {
    kubeconfig  = base64encode(data.template_file.kubeconfig.rendered)
    cmd_create  = <<-EOF
      cat <<YAML | kubectl -n ${var.k8s_namespace} --kubeconfig <(echo $KUBECONFIG | base64 --decode) apply -f -
      apiVersion: elbv2.k8s.aws/v1beta1
      kind: TargetGroupBinding
      metadata:
        name: ${lookup(var.target_groups[count.index], "name", "")}-tgb
      spec:
        serviceRef:
          name: ${lookup(var.target_groups[count.index], "name", "")}
          port: ${lookup(var.target_groups[count.index], "backend_port", "")}
        targetGroupARN: ${lookup(var.target_groups[count.index], "target_group_arn", "")}
        targetType:  ${lookup(var.target_groups[count.index], "target_type", "instance")}
      YAML
    EOF
    cmd_destroy = "kubectl -n ${var.k8s_namespace} --kubeconfig <(echo $KUBECONFIG | base64 --decode) delete TargetGroupBinding ${lookup(var.target_groups[count.index], "name", "")}-tgb"
  }

  provisioner "local-exec" {
    interpreter = ["/bin/bash", "-c"]
    environment = {
      KUBECONFIG = self.triggers.kubeconfig
    }
    command = self.triggers.cmd_create
  }
  provisioner "local-exec" {
    when        = destroy
    interpreter = ["/bin/bash", "-c"]
    environment = {
      KUBECONFIG = self.triggers.kubeconfig
    }
    command = self.triggers.cmd_destroy
  }
  depends_on = [helm_release.alb_controller]
}
